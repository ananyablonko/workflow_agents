import asyncio
from pydantic import RootModel, Field
from typing import AsyncGenerator, Optional, Annotated, Literal
from annotated_types import Len
from typing_extensions import override
from google.adk.agents import BaseAgent
from google.adk.agents.invocation_context import InvocationContext
from google.adk.events import Event, EventActions
from google.adk.agents.parallel_agent import _merge_agent_run
from google.genai import types

from google.adk.models.google_llm import logger


class GatherAgent(BaseAgent):
    sub_agents: Annotated[list[BaseAgent], Len(1, 1)] = Field(
        min_length=1, max_length=1,
        default_factory=list,
        description="A single base agent that will be copied and invoked for each prompt"
    )
    output_key: Optional[str] = None
    input_key: Optional[str] = None

    @property
    def agent(self):
        return self.sub_agents[0]

    @override
    async def _run_async_impl(
        self, invocation_context: InvocationContext
    ) -> AsyncGenerator[Event, None]:
        """Core logic of this workflow agent.

        Args:
            invocation_context: InvocationContext, provides access to the input prompts.

        Yields:
            Event: the events generated by the sub-agent for each input prompt.
        """

        # Create a branch string if it doesn't exist, to track where events are coming from when gathering results
        invocation_context.branch = invocation_context.branch or self.name

        prompts = self._extract_input_prompts(invocation_context)

        # for agent naming - e.g. if there are 100-999 prompts, sub-agent copies are named 001, 002, 003 and so on
        number_field_width = len(str(len(prompts)))  

        """
        Create a separate invocation context for each prompt, each with a numbered copy of the sub-agent.
        This handles renaming recursively in the sub-agent's tree.
        Additionally, sub-agents with output-key fields (usually LlmAgent) are tracked in _branch_context, used for this agent's output_key
        """
        key_agents = set()
        contexts = await asyncio.gather(*[
            self._branch_context(invocation_context, idx=i, prompt=prompt, width=number_field_width, key_agents=key_agents)
            for i, prompt in enumerate(prompts)
        ])

        # Invoke in parallel
        async for event in _merge_agent_run([ctx.agent.run_async(ctx) for ctx in contexts]):
            yield event

        # If this agent has no output_key we are done, we do not yield an aggregated result
        if not self.output_key:
            return

        # Gather the results from the sub-agent tree and save them to the state
        res = {
            name: [ctx.session.state.get(self._get_unique_name(i, number_field_width, name), None) for i, ctx in enumerate(contexts)]
            for name in key_agents
        }

        yield Event(
            invocation_id=invocation_context.invocation_id,
            branch=invocation_context.branch,
            author=self.name,
            actions=EventActions(state_delta={self.output_key: res}),
        )

    def _extract_input_prompts(self, ctx: InvocationContext) -> list[str]:
        """
        The input to the gather agent is a list of strings.
        We use input_key to get prompts as a list of strings from session state if available.
        Otherwise, extract the last user input from session events, and assume it is a list of strings serialized as a json string.
        """
        schema = RootModel[list[str]]

        if self.input_key is not None and self.input_key in ctx.session.state:
            agent_input = ctx.session.state.get(self.input_key, [])
            agent_input = schema.model_validate(agent_input)
        else:
            i, agent_input = next(
                (
                    (i, ((e.content or types.Content()).parts or [types.Part()])[0].text or "")
                    for i, e in enumerate(reversed(ctx.session.events))
                ), (0, '[]'),
            )
            agent_input = schema.model_validate_json(agent_input)
            """ 
            Remove the event which has the prompt list, so that a sub agent does not see the prompts of its siblings, which may confuse it.
            The event is removed only for this invocation.
            """
            ctx.session.events.pop(-i-1)  

        return agent_input.model_dump()

    @staticmethod
    def _get_unique_name(idx: int, width: int, name: str) -> str:
        """ e.g. my_sub_agent_046 """
        return f"{name}_{idx:0{width}d}"

    async def _branch_context(self, ctx: InvocationContext, *, idx: int, prompt: str, width: int, key_agents: set[str]) -> InvocationContext:
        """Creates a numbered copy of the sub-agent that sees a single prompt, and can run separately from its siblings.

        Args:
            ctx: InvocationContext, The current invocation context of the gather agent. To be copied and edited for the sub-agent copy.
            
            idx: int, the index of the prompt in the input prompts, serves as a unique identifier of the agent.
            
            prompt: str, the prompt on which the sub-agent copy should be invoked
            
            width: the number of digits in the total number of prompts, to ensure naming is consistent in field width
            
            (e.g. 001, 002, ... 010, 011, ... 100, 101; and not 1, 2, ... 10, 11, ... 100, 101)

        Returns:
            InvocationContext: A new invocation context ready to run with the unique sub-agent copy and the prompt
        """

        agent = self._branch_agent_tree(self.agent, idx, width, key_agents)

        branch = f"{ctx.branch}.{agent.name}"
        prompt_part = [types.Part(text=prompt)]

        # Add the prompt to the user_content of this branch to easily access agent input in callbacks
        new_ctx = ctx.model_copy(
            update=dict(
                branch=branch, agent=agent,
                user_content=types.Content(role="user", parts=((ctx.user_content or types.Content()).parts or []) + prompt_part),
            )
        )

        # Add the prompt as the most recent event of this branch in place of the prompt list as the natural input of the sub-agent
        await new_ctx.session_service.append_event(
            new_ctx.session,
            Event(
                author="user",
                branch=branch,
                content=types.Content(
                    role="user",
                    parts=prompt_part,
                ),
            ),
        )

        return new_ctx

    def _branch_agent_tree(self, agent: BaseAgent, idx: int, width: int, key_agents: set[str], inside_gather_agent: bool = False) -> BaseAgent:
        """
        This function serves multiple purposes:
        * it tracks which LlmAgents live in the sub-agent's tree so that we can save their outputs to the state without having them override one another.
        Note that 
        """
        is_gather = isinstance(agent, GatherAgent)
        new_agent = agent.model_copy()
        new_name = self._get_unique_name(idx, width, new_agent.name)
        if hasattr(new_agent, "output_key") and not inside_gather_agent:
            if getattr(new_agent, "output_key", None) is not None:
                logger.warning(
                    f"Overriding agent {new_agent.name} output_key. Normal state delta is not thread-safe, so regular output_key should not be used in GatherAgent sub-agents."
                )
            key_agents.add(agent.name)
            setattr(new_agent, "output_key", new_name)
        new_agent.name = new_name

        new_agent.sub_agents = [
            self._branch_agent_tree(a, idx, width, key_agents, inside_gather_agent=inside_gather_agent or is_gather)
            for a in agent.sub_agents
        ]
        return new_agent
